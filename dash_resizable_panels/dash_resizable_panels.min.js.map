{"version":3,"file":"dash_resizable_panels.min.js","mappings":"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","sources":["webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/make namespace object","webpack:///external window \"React\"","webpack:///external window \"PropTypes\"","webpack:///./node_modules/react-resizable-panels/dist/react-resizable-panels.browser.esm.js","webpack:///./src/lib/components/Panel.js","webpack:///./src/lib/components/PanelGroup.js","webpack:///./src/lib/components/PanelResizeHandle.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","var getCurrentScript = function() {\n    var script = document.currentScript;\n    if (!script) {\n        /* Shim for IE11 and below */\n        /* Do not take into account async scripts and inline scripts */\n\n        var doc_scripts = document.getElementsByTagName('script');\n        var scripts = [];\n\n        for (var i = 0; i < doc_scripts.length; i++) {\n            scripts.push(doc_scripts[i]);\n        }\n\n        scripts = scripts.filter(function(s) { return !s.async && !s.text && !s.textContent; });\n        script = scripts.slice(-1)[0];\n    }\n\n    return script;\n};\n\nvar isLocalScript = function(script) {\n    return /\\/_dash-component-suites\\//.test(script.src);\n};\n\nObject.defineProperty(__webpack_require__, 'p', {\n    get: (function () {\n        var script = getCurrentScript();\n\n        var url = script.src.split('/').slice(0, -1).join('/') + '/';\n\n        return function() {\n            return url;\n        };\n    })()\n});\n\nif (typeof jsonpScriptSrc !== 'undefined') {\n    var __jsonpScriptSrc__ = jsonpScriptSrc;\n    jsonpScriptSrc = function(chunkId) {\n        var script = getCurrentScript();\n        var isLocal = isLocalScript(script);\n\n        var src = __jsonpScriptSrc__(chunkId);\n\n        if(!isLocal) {\n            return src;\n        }\n\n        var srcFragments = src.split('/');\n        var fileFragments = srcFragments.slice(-1)[0].split('.');\n\n        fileFragments.splice(1, 0, \"v0_0_1m1701383978\");\n        srcFragments.splice(-1, 1, fileFragments.join('.'))\n\n        return srcFragments.join('/');\n    };\n}\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"React\"];","const __WEBPACK_NAMESPACE_OBJECT__ = window[\"PropTypes\"];","import * as React from 'react';\n\n// This module exists to work around Webpack issue https://github.com/webpack/webpack/issues/14814\n\n// eslint-disable-next-line no-restricted-imports\n\nconst {\n  createElement,\n  createContext,\n  createRef,\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState\n} = React;\n\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useId = React[\"useId\".toString()];\n\nconst PanelGroupContext = createContext(null);\nPanelGroupContext.displayName = \"PanelGroupContext\";\n\nconst useIsomorphicLayoutEffect = useLayoutEffect ;\n\nconst wrappedUseId = typeof useId === \"function\" ? useId : () => null;\nlet counter = 0;\nfunction useUniqueId(idFromParams = null) {\n  const idFromUseId = wrappedUseId();\n  const idRef = useRef(idFromParams || idFromUseId || null);\n  if (idRef.current === null) {\n    idRef.current = \"\" + counter++;\n  }\n  return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;\n}\n\nfunction PanelWithForwardedRef({\n  children,\n  className: classNameFromProps = \"\",\n  collapsedSizePercentage,\n  collapsedSizePixels,\n  collapsible,\n  dataAttributes,\n  defaultSizePercentage,\n  defaultSizePixels,\n  forwardedRef,\n  id: idFromProps,\n  maxSizePercentage,\n  maxSizePixels,\n  minSizePercentage,\n  minSizePixels,\n  onCollapse,\n  onExpand,\n  onResize,\n  order,\n  style: styleFromProps,\n  tagName: Type = \"div\"\n}) {\n  const context = useContext(PanelGroupContext);\n  if (context === null) {\n    throw Error(`Panel components must be rendered within a PanelGroup container`);\n  }\n  const {\n    collapsePanel,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    registerPanel,\n    resizePanel,\n    unregisterPanel\n  } = context;\n  const panelId = useUniqueId(idFromProps);\n  const panelDataRef = useRef({\n    callbacks: {\n      onCollapse,\n      onExpand,\n      onResize\n    },\n    constraints: {\n      collapsedSizePercentage,\n      collapsedSizePixels,\n      collapsible,\n      defaultSizePercentage,\n      defaultSizePixels,\n      maxSizePercentage,\n      maxSizePixels,\n      minSizePercentage,\n      minSizePixels\n    },\n    id: panelId,\n    idIsFromProps: idFromProps !== undefined,\n    order\n  });\n  useRef({\n    didLogMissingDefaultSizeWarning: false\n  });\n  useIsomorphicLayoutEffect(() => {\n    const {\n      callbacks,\n      constraints\n    } = panelDataRef.current;\n    panelDataRef.current.id = panelId;\n    panelDataRef.current.idIsFromProps = idFromProps !== undefined;\n    panelDataRef.current.order = order;\n    callbacks.onCollapse = onCollapse;\n    callbacks.onExpand = onExpand;\n    callbacks.onResize = onResize;\n    constraints.collapsedSizePercentage = collapsedSizePercentage;\n    constraints.collapsedSizePixels = collapsedSizePixels;\n    constraints.collapsible = collapsible;\n    constraints.defaultSizePercentage = defaultSizePercentage;\n    constraints.defaultSizePixels = defaultSizePixels;\n    constraints.maxSizePercentage = maxSizePercentage;\n    constraints.maxSizePixels = maxSizePixels;\n    constraints.minSizePercentage = minSizePercentage;\n    constraints.minSizePixels = minSizePixels;\n  });\n  useIsomorphicLayoutEffect(() => {\n    const panelData = panelDataRef.current;\n    registerPanel(panelData);\n    return () => {\n      unregisterPanel(panelData);\n    };\n  }, [order, panelId, registerPanel, unregisterPanel]);\n  useImperativeHandle(forwardedRef, () => ({\n    collapse: () => {\n      collapsePanel(panelDataRef.current);\n    },\n    expand: () => {\n      expandPanel(panelDataRef.current);\n    },\n    getId() {\n      return panelId;\n    },\n    getSize() {\n      return getPanelSize(panelDataRef.current);\n    },\n    isCollapsed() {\n      return isPanelCollapsed(panelDataRef.current);\n    },\n    isExpanded() {\n      return !isPanelCollapsed(panelDataRef.current);\n    },\n    resize: mixedSizes => {\n      resizePanel(panelDataRef.current, mixedSizes);\n    }\n  }), [collapsePanel, expandPanel, getPanelSize, isPanelCollapsed, panelId, resizePanel]);\n  const style = getPanelStyle(panelDataRef.current);\n  return createElement(Type, {\n    children,\n    className: classNameFromProps,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    ...dataAttributes,\n    // CSS selectors\n    \"data-panel\": \"\",\n    \"data-panel-id\": panelId,\n    \"data-panel-group-id\": groupId,\n    // e2e test attributes\n    \"data-panel-collapsible\": undefined,\n    \"data-panel-size\": undefined\n  });\n}\nconst Panel = forwardRef((props, ref) => createElement(PanelWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\n\nfunction convertPixelsToPercentage(pixels, groupSizePixels) {\n  return pixels / groupSizePixels * 100;\n}\n\nfunction convertPixelConstraintsToPercentages(panelConstraints, groupSizePixels) {\n  let {\n    collapsedSizePercentage = 0,\n    collapsedSizePixels,\n    defaultSizePercentage,\n    defaultSizePixels,\n    maxSizePercentage = 100,\n    maxSizePixels,\n    minSizePercentage = 0,\n    minSizePixels\n  } = panelConstraints;\n  const hasPixelConstraints = collapsedSizePixels != null || defaultSizePixels != null || minSizePixels != null || maxSizePixels != null;\n  if (hasPixelConstraints && groupSizePixels <= 0) {\n    console.warn(`WARNING: Invalid group size: ${groupSizePixels}px`);\n    return {\n      collapsedSizePercentage: 0,\n      defaultSizePercentage,\n      maxSizePercentage: 0,\n      minSizePercentage: 0\n    };\n  }\n  if (collapsedSizePixels != null) {\n    collapsedSizePercentage = convertPixelsToPercentage(collapsedSizePixels, groupSizePixels);\n  }\n  if (defaultSizePixels != null) {\n    defaultSizePercentage = convertPixelsToPercentage(defaultSizePixels, groupSizePixels);\n  }\n  if (minSizePixels != null) {\n    minSizePercentage = convertPixelsToPercentage(minSizePixels, groupSizePixels);\n  }\n  if (maxSizePixels != null) {\n    maxSizePercentage = convertPixelsToPercentage(maxSizePixels, groupSizePixels);\n  }\n  return {\n    collapsedSizePercentage,\n    defaultSizePercentage,\n    maxSizePercentage,\n    minSizePercentage\n  };\n}\n\nfunction computePercentagePanelConstraints(panelConstraintsArray, panelIndex, groupSizePixels) {\n  // All panel constraints, excluding the current one\n  let totalMinConstraints = 0;\n  let totalMaxConstraints = 0;\n  for (let index = 0; index < panelConstraintsArray.length; index++) {\n    if (index !== panelIndex) {\n      const {\n        collapsible\n      } = panelConstraintsArray[index];\n      const {\n        collapsedSizePercentage,\n        maxSizePercentage,\n        minSizePercentage\n      } = convertPixelConstraintsToPercentages(panelConstraintsArray[index], groupSizePixels);\n      totalMaxConstraints += maxSizePercentage;\n      totalMinConstraints += collapsible ? collapsedSizePercentage : minSizePercentage;\n    }\n  }\n  const {\n    collapsedSizePercentage,\n    defaultSizePercentage,\n    maxSizePercentage,\n    minSizePercentage\n  } = convertPixelConstraintsToPercentages(panelConstraintsArray[panelIndex], groupSizePixels);\n  return {\n    collapsedSizePercentage,\n    defaultSizePercentage,\n    maxSizePercentage: panelConstraintsArray.length > 1 ? Math.min(maxSizePercentage, 100 - totalMinConstraints) : maxSizePercentage,\n    minSizePercentage: panelConstraintsArray.length > 1 ? Math.max(minSizePercentage, 100 - totalMaxConstraints) : minSizePercentage\n  };\n}\n\nconst PRECISION = 10;\n\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\n  actual = parseFloat(actual.toFixed(fractionDigits));\n  expected = parseFloat(expected.toFixed(fractionDigits));\n  const delta = actual - expected;\n  if (delta === 0) {\n    return 0;\n  } else {\n    return delta > 0 ? 1 : -1;\n  }\n}\n\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits) {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n\n// Panel size must be in percentages; pixel values should be pre-converted\nfunction resizePanel({\n  groupSizePixels,\n  panelConstraints,\n  panelIndex,\n  size\n}) {\n  const hasPixelConstraints = panelConstraints.some(({\n    collapsedSizePixels,\n    defaultSizePixels,\n    minSizePixels,\n    maxSizePixels\n  }) => collapsedSizePixels != null || defaultSizePixels != null || minSizePixels != null || maxSizePixels != null);\n  if (hasPixelConstraints && groupSizePixels <= 0) {\n    console.warn(`WARNING: Invalid group size: ${groupSizePixels}px`);\n    return 0;\n  }\n  let {\n    collapsible\n  } = panelConstraints[panelIndex];\n  const {\n    collapsedSizePercentage,\n    maxSizePercentage,\n    minSizePercentage\n  } = computePercentagePanelConstraints(panelConstraints, panelIndex, groupSizePixels);\n  if (minSizePercentage != null) {\n    if (fuzzyCompareNumbers(size, minSizePercentage) < 0) {\n      if (collapsible) {\n        // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\n        const halfwayPoint = (collapsedSizePercentage + minSizePercentage) / 2;\n        if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n          size = collapsedSizePercentage;\n        } else {\n          size = minSizePercentage;\n        }\n      } else {\n        size = minSizePercentage;\n      }\n    }\n  }\n  if (maxSizePercentage != null) {\n    size = Math.min(maxSizePercentage, size);\n  }\n  return size;\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction adjustLayoutByDelta({\n  delta,\n  groupSizePixels,\n  layout: prevLayout,\n  panelConstraints,\n  pivotIndices,\n  trigger\n}) {\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return prevLayout;\n  }\n  const nextLayout = [...prevLayout];\n  let deltaApplied = 0;\n\n  //const DEBUG = [];\n  //DEBUG.push(`adjustLayoutByDelta() ${prevLayout.join(\", \")}`);\n  //DEBUG.push(`  delta: ${delta}`);\n  //DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\n  //DEBUG.push(`  trigger: ${trigger}`);\n  //DEBUG.push(\"\");\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel(s) immediately after the resize handle should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel(s) immediately before the resize handle should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resize handle.\n\n  {\n    // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n    // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\n    if (trigger === \"keyboard\") {\n      {\n        // Check if we should expand a collapsed panel\n        const index = delta < 0 ? pivotIndices[1] : pivotIndices[0];\n        const constraints = panelConstraints[index];\n        //DEBUG.push(`edge case check 1: ${index}`);\n        //DEBUG.push(`  -> collapsible? ${constraints.collapsible}`);\n        if (constraints.collapsible) {\n          const prevSize = prevLayout[index];\n          const {\n            collapsedSizePercentage,\n            minSizePercentage\n          } = computePercentagePanelConstraints(panelConstraints, index, groupSizePixels);\n          if (fuzzyNumbersEqual(prevSize, collapsedSizePercentage)) {\n            const localDelta = minSizePercentage - prevSize;\n            //DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              //DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n\n      {\n        // Check if we should collapse a panel at its minimum size\n        const index = delta < 0 ? pivotIndices[0] : pivotIndices[1];\n        const constraints = panelConstraints[index];\n        //DEBUG.push(`edge case check 2: ${index}`);\n        //DEBUG.push(`  -> collapsible? ${constraints.collapsible}`);\n        if (constraints.collapsible) {\n          const prevSize = prevLayout[index];\n          const {\n            collapsedSizePercentage,\n            minSizePercentage\n          } = computePercentagePanelConstraints(panelConstraints, index, groupSizePixels);\n          if (fuzzyNumbersEqual(prevSize, minSizePercentage)) {\n            const localDelta = prevSize - collapsedSizePercentage;\n            //DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              //DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n    }\n    //DEBUG.push(\"\");\n  }\n\n  {\n    // Pre-calculate max available delta in the opposite direction of our pivot.\n    // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\n    // If this amount is less than the requested delta, adjust the requested delta.\n    // If this amount is greater than the requested delta, that's useful information tooâ€“\n    // as an expanding panel might change from collapsed to min size.\n\n    const increment = delta < 0 ? 1 : -1;\n    let index = delta < 0 ? pivotIndices[1] : pivotIndices[0];\n    let maxAvailableDelta = 0;\n\n    //DEBUG.push(\"pre calc...\");\n    while (true) {\n      const prevSize = prevLayout[index];\n      const maxSafeSize = resizePanel({\n        groupSizePixels,\n        panelConstraints,\n        panelIndex: index,\n        size: 100\n      });\n      const delta = maxSafeSize - prevSize;\n      //DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\n\n      maxAvailableDelta += delta;\n      index += increment;\n      if (index < 0 || index >= panelConstraints.length) {\n        break;\n      }\n    }\n\n    //DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    //DEBUG.push(`  -> adjusted delta: ${delta}`);\n    //DEBUG.push(\"\");\n  }\n\n  {\n    // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\n\n    const pivotIndex = delta < 0 ? pivotIndices[0] : pivotIndices[1];\n    let index = pivotIndex;\n    while (index >= 0 && index < panelConstraints.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n      const prevSize = prevLayout[index];\n      const unsafeSize = prevSize - deltaRemaining;\n      const safeSize = resizePanel({\n        groupSizePixels,\n        panelConstraints,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n        deltaApplied += prevSize - safeSize;\n        nextLayout[index] = safeSize;\n        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), undefined, {\n          numeric: true\n        }) >= 0) {\n          break;\n        }\n      }\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  //DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\n  //DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  //DEBUG.push(\"\");\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore e.g. drags past a panel's boundaries\n  if (fuzzyNumbersEqual(deltaApplied, 0)) {\n    //console.log(DEBUG.join(\"\\n\"));\n    return prevLayout;\n  }\n  {\n    // Now distribute the applied delta to the panels in the other direction\n    const pivotIndex = delta < 0 ? pivotIndices[1] : pivotIndices[0];\n    const unsafeSize = prevLayout[pivotIndex] + deltaApplied;\n    const safeSize = resizePanel({\n      groupSizePixels,\n      panelConstraints,\n      panelIndex: pivotIndex,\n      size: unsafeSize\n    });\n\n    // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n    nextLayout[pivotIndex] = safeSize;\n\n    // Edge case where expanding or contracting one panel caused another one to change collapsed state\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n      const pivotIndex = delta < 0 ? pivotIndices[1] : pivotIndices[0];\n      let index = pivotIndex;\n      while (index >= 0 && index < panelConstraints.length) {\n        const prevSize = nextLayout[index];\n        const unsafeSize = prevSize + deltaRemaining;\n        const safeSize = resizePanel({\n          groupSizePixels,\n          panelConstraints,\n          panelIndex: index,\n          size: unsafeSize\n        });\n        if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n          deltaRemaining -= safeSize - prevSize;\n          nextLayout[index] = safeSize;\n        }\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  //DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\n  //DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  //DEBUG.push(\"\");\n\n  const totalSize = nextLayout.reduce((total, size) => size + total, 0);\n  deltaApplied = 100 - totalSize;\n  //DEBUG.push(`total size: ${totalSize}`);\n  //DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  //console.log(DEBUG.join(\"\\n\"));\n\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    return prevLayout;\n  }\n  return nextLayout;\n}\n\nfunction assert(expectedCondition, message = \"Assertion failed!\") {\n  if (!expectedCondition) {\n    console.error(message);\n    throw Error(message);\n  }\n}\n\nfunction getPercentageSizeFromMixedSizes({\n  sizePercentage,\n  sizePixels\n}, groupSizePixels) {\n  if (sizePercentage != null) {\n    return sizePercentage;\n  } else if (sizePixels != null) {\n    return convertPixelsToPercentage(sizePixels, groupSizePixels);\n  }\n  return undefined;\n}\n\nfunction calculateAriaValues({\n  groupSizePixels,\n  layout,\n  panelsArray,\n  pivotIndices\n}) {\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n\n  // A panel's effective min/max sizes also need to account for other panel's sizes.\n  panelsArray.forEach((panelData, index) => {\n    var _getPercentageSizeFro, _getPercentageSizeFro2;\n    const {\n      constraints\n    } = panelData;\n    const {\n      maxSizePercentage,\n      maxSizePixels,\n      minSizePercentage,\n      minSizePixels\n    } = constraints;\n    const minSize = (_getPercentageSizeFro = getPercentageSizeFromMixedSizes({\n      sizePercentage: minSizePercentage,\n      sizePixels: minSizePixels\n    }, groupSizePixels)) !== null && _getPercentageSizeFro !== void 0 ? _getPercentageSizeFro : 0;\n    const maxSize = (_getPercentageSizeFro2 = getPercentageSizeFromMixedSizes({\n      sizePercentage: maxSizePercentage,\n      sizePixels: maxSizePixels\n    }, groupSizePixels)) !== null && _getPercentageSizeFro2 !== void 0 ? _getPercentageSizeFro2 : 100;\n    if (index === pivotIndices[0]) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  });\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n  const valueNow = layout[pivotIndices[0]];\n  return {\n    valueMax,\n    valueMin,\n    valueNow\n  };\n}\n\nfunction getResizeHandleElementsForGroup(groupId) {\n  return Array.from(document.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id=\"${groupId}\"]`));\n}\n\nfunction getResizeHandleElementIndex(groupId, id) {\n  const handles = getResizeHandleElementsForGroup(groupId);\n  const index = handles.findIndex(handle => handle.getAttribute(\"data-panel-resize-handle-id\") === id);\n  return index !== null && index !== void 0 ? index : null;\n}\n\nfunction determinePivotIndices(groupId, dragHandleId) {\n  const index = getResizeHandleElementIndex(groupId, dragHandleId);\n  return index != null ? [index, index + 1] : [-1, -1];\n}\n\nfunction getPanelGroupElement(id) {\n  const element = document.querySelector(`[data-panel-group][data-panel-group-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction calculateAvailablePanelSizeInPixels(groupId) {\n  const panelGroupElement = getPanelGroupElement(groupId);\n  if (panelGroupElement == null) {\n    return NaN;\n  }\n  const direction = panelGroupElement.getAttribute(\"data-panel-group-direction\");\n  const resizeHandles = getResizeHandleElementsForGroup(groupId);\n  if (direction === \"horizontal\") {\n    return panelGroupElement.offsetWidth - resizeHandles.reduce((accumulated, handle) => {\n      return accumulated + handle.offsetWidth;\n    }, 0);\n  } else {\n    return panelGroupElement.offsetHeight - resizeHandles.reduce((accumulated, handle) => {\n      return accumulated + handle.offsetHeight;\n    }, 0);\n  }\n}\n\nfunction getAvailableGroupSizePixels(groupId) {\n  const panelGroupElement = getPanelGroupElement(groupId);\n  if (panelGroupElement == null) {\n    return NaN;\n  }\n  const direction = panelGroupElement.getAttribute(\"data-panel-group-direction\");\n  const resizeHandles = getResizeHandleElementsForGroup(groupId);\n  if (direction === \"horizontal\") {\n    return panelGroupElement.offsetWidth - resizeHandles.reduce((accumulated, handle) => {\n      return accumulated + handle.offsetWidth;\n    }, 0);\n  } else {\n    return panelGroupElement.offsetHeight - resizeHandles.reduce((accumulated, handle) => {\n      return accumulated + handle.offsetHeight;\n    }, 0);\n  }\n}\n\nfunction getResizeHandleElement(id) {\n  const element = document.querySelector(`[data-panel-resize-handle-id=\"${id}\"]`);\n  if (element) {\n    return element;\n  }\n  return null;\n}\n\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray) {\n  var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;\n  const handle = getResizeHandleElement(handleId);\n  const handles = getResizeHandleElementsForGroup(groupId);\n  const index = handle ? handles.indexOf(handle) : -1;\n  const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;\n  const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;\n  return [idBefore, idAfter];\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterPanelGroupBehavior({\n  committedValuesRef,\n  eagerValuesRef,\n  groupId,\n  layout,\n  panelDataArray,\n  setLayout\n}) {\n  useRef({\n    didWarnAboutMissingResizeHandle: false\n  });\n  useIsomorphicLayoutEffect(() => {\n    const groupSizePixels = calculateAvailablePanelSizeInPixels(groupId);\n    const resizeHandleElements = getResizeHandleElementsForGroup(groupId);\n    for (let index = 0; index < panelDataArray.length - 1; index++) {\n      const {\n        valueMax,\n        valueMin,\n        valueNow\n      } = calculateAriaValues({\n        groupSizePixels,\n        layout,\n        panelsArray: panelDataArray,\n        pivotIndices: [index, index + 1]\n      });\n      const resizeHandleElement = resizeHandleElements[index];\n      if (resizeHandleElement == null) ; else {\n        resizeHandleElement.setAttribute(\"aria-controls\", panelDataArray[index].id);\n        resizeHandleElement.setAttribute(\"aria-valuemax\", \"\" + Math.round(valueMax));\n        resizeHandleElement.setAttribute(\"aria-valuemin\", \"\" + Math.round(valueMin));\n        resizeHandleElement.setAttribute(\"aria-valuenow\", \"\" + Math.round(valueNow));\n      }\n    }\n    return () => {\n      resizeHandleElements.forEach((resizeHandleElement, index) => {\n        resizeHandleElement.removeAttribute(\"aria-controls\");\n        resizeHandleElement.removeAttribute(\"aria-valuemax\");\n        resizeHandleElement.removeAttribute(\"aria-valuemin\");\n        resizeHandleElement.removeAttribute(\"aria-valuenow\");\n      });\n    };\n  }, [groupId, layout, panelDataArray]);\n  useEffect(() => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const groupElement = getPanelGroupElement(groupId);\n    assert(groupElement != null, `No group found for id \"${groupId}\"`);\n    const handles = getResizeHandleElementsForGroup(groupId);\n    const cleanupFunctions = handles.map(handle => {\n      const handleId = handle.getAttribute(\"data-panel-resize-handle-id\");\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray);\n      if (idBefore == null || idAfter == null) {\n        return () => {};\n      }\n      const onKeyDown = event => {\n        if (event.defaultPrevented) {\n          return;\n        }\n        switch (event.key) {\n          case \"Enter\":\n            {\n              event.preventDefault();\n              const index = panelDataArray.findIndex(panelData => panelData.id === idBefore);\n              if (index >= 0) {\n                const panelData = panelDataArray[index];\n                const size = layout[index];\n                if (size != null && panelData.constraints.collapsible) {\n                  var _getPercentageSizeFro, _getPercentageSizeFro2;\n                  const groupSizePixels = getAvailableGroupSizePixels(groupId);\n                  const collapsedSize = (_getPercentageSizeFro = getPercentageSizeFromMixedSizes({\n                    sizePercentage: panelData.constraints.collapsedSizePercentage,\n                    sizePixels: panelData.constraints.collapsedSizePixels\n                  }, groupSizePixels)) !== null && _getPercentageSizeFro !== void 0 ? _getPercentageSizeFro : 0;\n                  const minSize = (_getPercentageSizeFro2 = getPercentageSizeFromMixedSizes({\n                    sizePercentage: panelData.constraints.minSizePercentage,\n                    sizePixels: panelData.constraints.minSizePixels\n                  }, groupSizePixels)) !== null && _getPercentageSizeFro2 !== void 0 ? _getPercentageSizeFro2 : 0;\n                  const nextLayout = adjustLayoutByDelta({\n                    delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\n                    groupSizePixels,\n                    layout,\n                    panelConstraints: panelDataArray.map(panelData => panelData.constraints),\n                    pivotIndices: determinePivotIndices(groupId, handleId),\n                    trigger: \"keyboard\"\n                  });\n                  if (layout !== nextLayout) {\n                    setLayout(nextLayout);\n                  }\n                }\n              }\n              break;\n            }\n        }\n      };\n      handle.addEventListener(\"keydown\", onKeyDown);\n      return () => {\n        handle.removeEventListener(\"keydown\", onKeyDown);\n      };\n    });\n    return () => {\n      cleanupFunctions.forEach(cleanupFunction => cleanupFunction());\n    };\n  }, [committedValuesRef, eagerValuesRef, groupId, layout, panelDataArray, setLayout]);\n}\n\nfunction areEqual(arrayA, arrayB) {\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n  for (let index = 0; index < arrayA.length; index++) {\n    if (arrayA[index] !== arrayB[index]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction isKeyDown(event) {\n  return event.type === \"keydown\";\n}\nfunction isMouseEvent(event) {\n  return event.type.startsWith(\"mouse\");\n}\nfunction isTouchEvent(event) {\n  return event.type.startsWith(\"touch\");\n}\n\nfunction getResizeEventCursorPosition(direction, event) {\n  const isHorizontal = direction === \"horizontal\";\n  if (isMouseEvent(event)) {\n    return isHorizontal ? event.clientX : event.clientY;\n  } else if (isTouchEvent(event)) {\n    const firstTouch = event.touches[0];\n    return isHorizontal ? firstTouch.screenX : firstTouch.screenY;\n  } else {\n    throw Error(`Unsupported event type \"${event.type}\"`);\n  }\n}\n\nfunction calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState) {\n  const isHorizontal = direction === \"horizontal\";\n  const handleElement = getResizeHandleElement(dragHandleId);\n  const groupId = handleElement.getAttribute(\"data-panel-group-id\");\n  let {\n    initialCursorPosition\n  } = initialDragState;\n  const cursorPosition = getResizeEventCursorPosition(direction, event);\n  const groupElement = getPanelGroupElement(groupId);\n  const groupRect = groupElement.getBoundingClientRect();\n  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n  const offsetPixels = cursorPosition - initialCursorPosition;\n  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\n  return offsetPercentage;\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nfunction calculateDeltaPercentage(event, groupId, dragHandleId, direction, initialDragState, keyboardResizeByOptions) {\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === \"horizontal\";\n    const groupElement = getPanelGroupElement(groupId);\n    const rect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? rect.width : rect.height;\n    let delta = 0;\n    if (event.shiftKey) {\n      delta = 100;\n    } else if (keyboardResizeByOptions.percentage != null) {\n      delta = keyboardResizeByOptions.percentage;\n    } else if (keyboardResizeByOptions.pixels != null) {\n      delta = keyboardResizeByOptions.pixels / groupSizeInPixels;\n    } else {\n      delta = 10;\n    }\n    let movement = 0;\n    switch (event.key) {\n      case \"ArrowDown\":\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case \"ArrowLeft\":\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case \"ArrowRight\":\n        movement = isHorizontal ? delta : 0;\n        break;\n      case \"ArrowUp\":\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case \"End\":\n        movement = 100;\n        break;\n      case \"Home\":\n        movement = -100;\n        break;\n    }\n    return movement;\n  } else {\n    return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState);\n  }\n}\n\nfunction calculateUnsafeDefaultLayout({\n  groupSizePixels,\n  panelDataArray\n}) {\n  const layout = Array(panelDataArray.length);\n  const panelDataConstraints = panelDataArray.map(panelData => panelData.constraints);\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n\n  // Distribute default sizes first\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const {\n      defaultSizePercentage\n    } = computePercentagePanelConstraints(panelDataConstraints, index, groupSizePixels);\n    if (defaultSizePercentage != null) {\n      numPanelsWithSizes++;\n      layout[index] = defaultSizePercentage;\n      remainingSize -= defaultSizePercentage;\n    }\n  }\n\n  // Remaining size should be distributed evenly between panels without default sizes\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const {\n      defaultSizePercentage\n    } = computePercentagePanelConstraints(panelDataConstraints, index, groupSizePixels);\n    if (defaultSizePercentage != null) {\n      continue;\n    }\n    const numRemainingPanels = panelDataArray.length - numPanelsWithSizes;\n    const size = remainingSize / numRemainingPanels;\n    numPanelsWithSizes++;\n    layout[index] = size;\n    remainingSize -= size;\n  }\n  return layout;\n}\n\nfunction convertPercentageToPixels(percentage, groupSizePixels) {\n  return percentage / 100 * groupSizePixels;\n}\n\n// Layout should be pre-converted into percentages\nfunction callPanelCallbacks(groupId, panelsArray, layout, panelIdToLastNotifiedMixedSizesMap) {\n  const groupSizePixels = calculateAvailablePanelSizeInPixels(groupId);\n  layout.forEach((sizePercentage, index) => {\n    const panelData = panelsArray[index];\n    if (!panelData) {\n      // Handle initial mount (when panels are registered too late to be in the panels array)\n      // The subsequent render+effects will handle the resize notification\n      return;\n    }\n    const {\n      callbacks,\n      constraints,\n      id: panelId\n    } = panelData;\n    const {\n      collapsible\n    } = constraints;\n    const mixedSizes = {\n      sizePercentage,\n      sizePixels: convertPercentageToPixels(sizePercentage, groupSizePixels)\n    };\n    const lastNotifiedMixedSizes = panelIdToLastNotifiedMixedSizesMap[panelId];\n    if (lastNotifiedMixedSizes == null || mixedSizes.sizePercentage !== lastNotifiedMixedSizes.sizePercentage || mixedSizes.sizePixels !== lastNotifiedMixedSizes.sizePixels) {\n      panelIdToLastNotifiedMixedSizesMap[panelId] = mixedSizes;\n      const {\n        onCollapse,\n        onExpand,\n        onResize\n      } = callbacks;\n      if (onResize) {\n        onResize(mixedSizes, lastNotifiedMixedSizes);\n      }\n      if (collapsible && (onCollapse || onExpand)) {\n        var _getPercentageSizeFro;\n        const collapsedSize = (_getPercentageSizeFro = getPercentageSizeFromMixedSizes({\n          sizePercentage: constraints.collapsedSizePercentage,\n          sizePixels: constraints.collapsedSizePixels\n        }, groupSizePixels)) !== null && _getPercentageSizeFro !== void 0 ? _getPercentageSizeFro : 0;\n        const size = getPercentageSizeFromMixedSizes(mixedSizes, groupSizePixels);\n        if (onExpand && (lastNotifiedMixedSizes == null || lastNotifiedMixedSizes.sizePercentage === collapsedSize) && size !== collapsedSize) {\n          onExpand();\n        }\n        if (onCollapse && (lastNotifiedMixedSizes == null || lastNotifiedMixedSizes.sizePercentage !== collapsedSize) && size === collapsedSize) {\n          onCollapse();\n        }\n      }\n    }\n  });\n}\n\nfunction compareLayouts(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  } else {\n    for (let index = 0; index < a.length; index++) {\n      if (a[index] != b[index]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n// This method returns a number between 1 and 100 representing\n\n// the % of the group's overall space this panel should occupy.\nfunction computePanelFlexBoxStyle({\n  dragState,\n  layout,\n  panelData,\n  panelIndex,\n  precision = 3\n}) {\n  const size = layout[panelIndex];\n  let flexGrow;\n  if (panelData.length === 1) {\n    flexGrow = \"1\";\n  } else if (size == null) {\n    // Initial render (before panels have registered themselves)\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toPrecision(precision);\n  }\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : undefined\n  };\n}\n\nlet currentState = null;\nlet element = null;\nfunction getCursorStyle(state) {\n  switch (state) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"horizontal-max\":\n      return \"w-resize\";\n    case \"horizontal-min\":\n      return \"e-resize\";\n    case \"vertical\":\n      return \"ns-resize\";\n    case \"vertical-max\":\n      return \"n-resize\";\n    case \"vertical-min\":\n      return \"s-resize\";\n  }\n}\nfunction resetGlobalCursorStyle() {\n  if (element !== null) {\n    document.head.removeChild(element);\n    currentState = null;\n    element = null;\n  }\n}\nfunction setGlobalCursorStyle(state) {\n  if (currentState === state) {\n    return;\n  }\n  currentState = state;\n  const style = getCursorStyle(state);\n  if (element === null) {\n    element = document.createElement(\"style\");\n    document.head.appendChild(element);\n  }\n  element.innerHTML = `*{cursor: ${style}!important;}`;\n}\n\nfunction debounce(callback, durationMs = 10) {\n  let timeoutId = null;\n  let callable = (...args) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n  return callable;\n}\n\nfunction getPanelElementsForGroup(groupId) {\n  return Array.from(document.querySelectorAll(`[data-panel][data-panel-group-id=\"${groupId}\"]`));\n}\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nfunction initializeDefaultStorage(storageObject) {\n  try {\n    if (typeof localStorage !== \"undefined\") {\n      // Bypass this check for future calls\n      storageObject.getItem = name => {\n        return localStorage.getItem(name);\n      };\n      storageObject.setItem = (name, value) => {\n        localStorage.setItem(name, value);\n      };\n    } else {\n      throw new Error(\"localStorage not supported in this environment\");\n    }\n  } catch (error) {\n    console.error(error);\n    storageObject.getItem = () => null;\n    storageObject.setItem = () => {};\n  }\n}\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using the min/max size attributes should work well enough as a backup.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getSerializationKey(panels) {\n  return panels.map(panel => {\n    const {\n      constraints,\n      id,\n      idIsFromProps,\n      order\n    } = panel;\n    if (idIsFromProps) {\n      return id;\n    } else {\n      return `${order}:${JSON.stringify(constraints)}`;\n    }\n  }).sort((a, b) => a.localeCompare(b)).join(\",\");\n}\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\n  try {\n    const serialized = storage.getItem(`PanelGroup:sizes:${autoSaveId}`);\n    if (serialized) {\n      const parsed = JSON.parse(serialized);\n      if (typeof parsed === \"object\" && parsed != null) {\n        return parsed;\n      }\n    }\n  } catch (error) {}\n  return null;\n}\nfunction loadPanelLayout(autoSaveId, panels, storage) {\n  const state = loadSerializedPanelGroupState(autoSaveId, storage);\n  if (state) {\n    var _state$key;\n    const key = getSerializationKey(panels);\n    return (_state$key = state[key]) !== null && _state$key !== void 0 ? _state$key : null;\n  }\n  return null;\n}\nfunction savePanelGroupLayout(autoSaveId, panels, sizes, storage) {\n  const key = getSerializationKey(panels);\n  const state = loadSerializedPanelGroupState(autoSaveId, storage) || {};\n  state[key] = sizes;\n  try {\n    storage.setItem(`PanelGroup:sizes:${autoSaveId}`, JSON.stringify(state));\n  } catch (error) {\n    console.error(error);\n  }\n}\n\nfunction shouldMonitorPixelBasedConstraints(constraints) {\n  return constraints.some(constraints => {\n    return constraints.collapsedSizePixels !== undefined || constraints.maxSizePixels !== undefined || constraints.minSizePixels !== undefined;\n  });\n}\n\n// All units must be in percentages; pixel values should be pre-converted\nfunction validatePanelGroupLayout({\n  groupSizePixels,\n  layout: prevLayout,\n  panelConstraints\n}) {\n  const nextLayout = [...prevLayout];\n\n  // Validate layout expectations\n  if (nextLayout.length !== panelConstraints.length) {\n    throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map(size => `${size}%`).join(\", \")}`);\n  } else if (!fuzzyNumbersEqual(nextLayout.reduce((accumulated, current) => accumulated + current, 0), 100)) ;\n  let remainingSize = 0;\n\n  // First pass: Validate the proposed layout given each panel's constraints\n  for (let index = 0; index < panelConstraints.length; index++) {\n    const unsafeSize = nextLayout[index];\n    const safeSize = resizePanel({\n      groupSizePixels,\n      panelConstraints,\n      panelIndex: index,\n      size: unsafeSize\n    });\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const prevSize = nextLayout[index];\n      const unsafeSize = prevSize + remainingSize;\n      const safeSize = resizePanel({\n        groupSizePixels,\n        panelConstraints,\n        panelIndex: index,\n        size: unsafeSize\n      });\n      if (prevSize !== safeSize) {\n        remainingSize -= safeSize - prevSize;\n        nextLayout[index] = safeSize;\n\n        // Once we've used up the remainder, bail\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n  return nextLayout;\n}\n\nconst LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\nconst defaultStorage = {\n  getItem: name => {\n    initializeDefaultStorage(defaultStorage);\n    return defaultStorage.getItem(name);\n  },\n  setItem: (name, value) => {\n    initializeDefaultStorage(defaultStorage);\n    defaultStorage.setItem(name, value);\n  }\n};\nconst debounceMap = {};\nfunction PanelGroupWithForwardedRef({\n  autoSaveId = null,\n  children,\n  className: classNameFromProps = \"\",\n  dataAttributes,\n  direction,\n  forwardedRef,\n  id: idFromProps,\n  onLayout = null,\n  keyboardResizeByPercentage = null,\n  keyboardResizeByPixels = null,\n  storage = defaultStorage,\n  style: styleFromProps,\n  tagName: Type = \"div\"\n}) {\n  const groupId = useUniqueId(idFromProps);\n  const [dragState, setDragState] = useState(null);\n  const [layout, setLayout] = useState([]);\n  const panelIdToLastNotifiedMixedSizesMapRef = useRef({});\n  const panelSizeBeforeCollapseRef = useRef(new Map());\n  const prevDeltaRef = useRef(0);\n  const committedValuesRef = useRef({\n    autoSaveId,\n    direction,\n    dragState,\n    id: groupId,\n    keyboardResizeByPercentage,\n    keyboardResizeByPixels,\n    onLayout,\n    storage\n  });\n  const eagerValuesRef = useRef({\n    layout,\n    panelDataArray: []\n  });\n  useRef({\n    didLogIdAndOrderWarning: false,\n    didLogPanelConstraintsWarning: false,\n    prevPanelIds: []\n  });\n  useImperativeHandle(forwardedRef, () => ({\n    getId: () => committedValuesRef.current.id,\n    getLayout: () => {\n      const {\n        id: groupId\n      } = committedValuesRef.current;\n      const {\n        layout\n      } = eagerValuesRef.current;\n      const groupSizePixels = calculateAvailablePanelSizeInPixels(groupId);\n      return layout.map(sizePercentage => {\n        return {\n          sizePercentage,\n          sizePixels: convertPercentageToPixels(sizePercentage, groupSizePixels)\n        };\n      });\n    },\n    setLayout: mixedSizes => {\n      const {\n        id: groupId,\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const groupSizePixels = calculateAvailablePanelSizeInPixels(groupId);\n      const unsafeLayout = mixedSizes.map(mixedSize => getPercentageSizeFromMixedSizes(mixedSize, groupSizePixels));\n      const safeLayout = validatePanelGroupLayout({\n        groupSizePixels,\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, safeLayout)) {\n        setLayout(safeLayout);\n        eagerValuesRef.current.layout = safeLayout;\n        if (onLayout) {\n          onLayout(safeLayout.map(sizePercentage => ({\n            sizePercentage,\n            sizePixels: convertPercentageToPixels(sizePercentage, groupSizePixels)\n          })));\n        }\n        callPanelCallbacks(groupId, panelDataArray, safeLayout, panelIdToLastNotifiedMixedSizesMapRef.current);\n      }\n    }\n  }), []);\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.autoSaveId = autoSaveId;\n    committedValuesRef.current.direction = direction;\n    committedValuesRef.current.dragState = dragState;\n    committedValuesRef.current.id = groupId;\n    committedValuesRef.current.onLayout = onLayout;\n    committedValuesRef.current.storage = storage;\n\n    // panelDataArray and layout are updated in-sync with scheduled state updates.\n    // TODO [217] Move these values into a separate ref\n  });\n\n  useWindowSplitterPanelGroupBehavior({\n    committedValuesRef,\n    eagerValuesRef,\n    groupId,\n    layout,\n    panelDataArray: eagerValuesRef.current.panelDataArray,\n    setLayout\n  });\n  useEffect(() => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\n    if (autoSaveId) {\n      if (layout.length === 0 || layout.length !== panelDataArray.length) {\n        return;\n      }\n\n      // Limit the frequency of localStorage updates.\n      if (!debounceMap[autoSaveId]) {\n        debounceMap[autoSaveId] = debounce(savePanelGroupLayout, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\n      }\n      debounceMap[autoSaveId](autoSaveId, panelDataArray, layout, storage);\n    }\n  }, [autoSaveId, layout, storage]);\n  useIsomorphicLayoutEffect(() => {\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const constraints = panelDataArray.map(({\n      constraints\n    }) => constraints);\n    if (!shouldMonitorPixelBasedConstraints(constraints)) {\n      // Avoid the overhead of ResizeObserver if no pixel constraints require monitoring\n      return;\n    }\n    if (typeof ResizeObserver === \"undefined\") {\n      console.warn(`WARNING: Pixel based constraints require ResizeObserver but it is not supported by the current browser.`);\n    } else {\n      const resizeObserver = new ResizeObserver(() => {\n        const groupSizePixels = calculateAvailablePanelSizeInPixels(groupId);\n        const {\n          onLayout\n        } = committedValuesRef.current;\n        const nextLayout = validatePanelGroupLayout({\n          groupSizePixels,\n          layout: prevLayout,\n          panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n        });\n        if (!areEqual(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout.map(sizePercentage => ({\n              sizePercentage,\n              sizePixels: convertPercentageToPixels(sizePercentage, groupSizePixels)\n            })));\n          }\n          callPanelCallbacks(groupId, panelDataArray, nextLayout, panelIdToLastNotifiedMixedSizesMapRef.current);\n        }\n      });\n      resizeObserver.observe(getPanelGroupElement(groupId));\n      return () => {\n        resizeObserver.disconnect();\n      };\n    }\n  }, [groupId]);\n\n  // DEV warnings\n  useEffect(() => {\n  });\n\n  // External APIs are safe to memoize via committed values ref\n  const collapsePanel = useCallback(panelData => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSizePercentage,\n        panelSizePercentage,\n        pivotIndices,\n        groupSizePixels\n      } = panelDataHelper(groupId, panelDataArray, panelData, prevLayout);\n      if (panelSizePercentage !== collapsedSizePercentage) {\n        // Store size before collapse;\n        // This is the size that gets restored if the expand() API is used.\n        panelSizeBeforeCollapseRef.current.set(panelData.id, panelSizePercentage);\n        const isLastPanel = panelDataArray.indexOf(panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSizePercentage - collapsedSizePercentage : collapsedSizePercentage - panelSizePercentage;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          groupSizePixels,\n          layout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout.map(sizePercentage => ({\n              sizePercentage,\n              sizePixels: convertPercentageToPixels(sizePercentage, groupSizePixels)\n            })));\n          }\n          callPanelCallbacks(groupId, panelDataArray, nextLayout, panelIdToLastNotifiedMixedSizesMapRef.current);\n        }\n      }\n    }\n  }, [groupId]);\n\n  // External APIs are safe to memoize via committed values ref\n  const expandPanel = useCallback(panelData => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    if (panelData.constraints.collapsible) {\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n      const {\n        collapsedSizePercentage,\n        panelSizePercentage,\n        minSizePercentage,\n        pivotIndices,\n        groupSizePixels\n      } = panelDataHelper(groupId, panelDataArray, panelData, prevLayout);\n      if (panelSizePercentage === collapsedSizePercentage) {\n        // Restore this panel to the size it was before it was collapsed, if possible.\n        const prevPanelSizePercentage = panelSizeBeforeCollapseRef.current.get(panelData.id);\n        const baseSizePercentage = prevPanelSizePercentage != null && prevPanelSizePercentage >= minSizePercentage ? prevPanelSizePercentage : minSizePercentage;\n        const isLastPanel = panelDataArray.indexOf(panelData) === panelDataArray.length - 1;\n        const delta = isLastPanel ? panelSizePercentage - baseSizePercentage : baseSizePercentage - panelSizePercentage;\n        const nextLayout = adjustLayoutByDelta({\n          delta,\n          groupSizePixels,\n          layout: prevLayout,\n          panelConstraints: panelConstraintsArray,\n          pivotIndices,\n          trigger: \"imperative-api\"\n        });\n        if (!compareLayouts(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n          eagerValuesRef.current.layout = nextLayout;\n          if (onLayout) {\n            onLayout(nextLayout.map(sizePercentage => ({\n              sizePercentage,\n              sizePixels: convertPercentageToPixels(sizePercentage, groupSizePixels)\n            })));\n          }\n          callPanelCallbacks(groupId, panelDataArray, nextLayout, panelIdToLastNotifiedMixedSizesMapRef.current);\n        }\n      }\n    }\n  }, [groupId]);\n\n  // External APIs are safe to memoize via committed values ref\n  const getPanelSize = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      panelSizePercentage,\n      panelSizePixels\n    } = panelDataHelper(groupId, panelDataArray, panelData, layout);\n    return {\n      sizePercentage: panelSizePercentage,\n      sizePixels: panelSizePixels\n    };\n  }, [groupId]);\n\n  // This API should never read from committedValuesRef\n  const getPanelStyle = useCallback(panelData => {\n    const {\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelIndex = panelDataArray.indexOf(panelData);\n    return computePanelFlexBoxStyle({\n      dragState,\n      layout,\n      panelData: panelDataArray,\n      panelIndex\n    });\n  }, [dragState, layout]);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelCollapsed = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSizePercentage,\n      collapsible,\n      panelSizePercentage\n    } = panelDataHelper(groupId, panelDataArray, panelData, layout);\n    return collapsible === true && panelSizePercentage === collapsedSizePercentage;\n  }, [groupId]);\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelExpanded = useCallback(panelData => {\n    const {\n      layout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const {\n      collapsedSizePercentage,\n      collapsible,\n      panelSizePercentage\n    } = panelDataHelper(groupId, panelDataArray, panelData, layout);\n    return !collapsible || panelSizePercentage > collapsedSizePercentage;\n  }, [groupId]);\n  const registerPanel = useCallback(panelData => {\n    const {\n      autoSaveId,\n      id: groupId,\n      onLayout,\n      storage\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    panelDataArray.push(panelData);\n    panelDataArray.sort((panelA, panelB) => {\n      const orderA = panelA.order;\n      const orderB = panelB.order;\n      if (orderA == null && orderB == null) {\n        return 0;\n      } else if (orderA == null) {\n        return -1;\n      } else if (orderB == null) {\n        return 1;\n      } else {\n        return orderA - orderB;\n      }\n    });\n\n    // Wait until all panels have registered before we try to compute layout;\n    // doing it earlier is both wasteful and may trigger misleading warnings in development mode.\n    const panelElements = getPanelElementsForGroup(groupId);\n    if (panelElements.length !== panelDataArray.length) {\n      return;\n    }\n\n    // If this panel has been configured to persist sizing information,\n    // default size should be restored from local storage if possible.\n    let unsafeLayout = null;\n    if (autoSaveId) {\n      unsafeLayout = loadPanelLayout(autoSaveId, panelDataArray, storage);\n    }\n    const groupSizePixels = calculateAvailablePanelSizeInPixels(groupId);\n    if (groupSizePixels <= 0) {\n      if (shouldMonitorPixelBasedConstraints(panelDataArray.map(({\n        constraints\n      }) => constraints))) {\n        // Wait until the group has rendered a non-zero size before computing layout.\n        return;\n      }\n    }\n    if (unsafeLayout == null) {\n      unsafeLayout = calculateUnsafeDefaultLayout({\n        groupSizePixels,\n        panelDataArray\n      });\n    }\n\n    // Validate even saved layouts in case something has changed since last render\n    // e.g. for pixel groups, this could be the size of the window\n    const nextLayout = validatePanelGroupLayout({\n      groupSizePixels,\n      layout: unsafeLayout,\n      panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n    });\n\n    // Offscreen mode makes this a bit weird;\n    // Panels unregister when hidden and re-register when shown again,\n    // but the overall layout doesn't change between these two cases.\n    setLayout(nextLayout);\n    eagerValuesRef.current.layout = nextLayout;\n    if (!areEqual(prevLayout, nextLayout)) {\n      if (onLayout) {\n        onLayout(nextLayout.map(sizePercentage => ({\n          sizePercentage,\n          sizePixels: convertPercentageToPixels(sizePercentage, groupSizePixels)\n        })));\n      }\n      callPanelCallbacks(groupId, panelDataArray, nextLayout, panelIdToLastNotifiedMixedSizesMapRef.current);\n    }\n  }, []);\n  const registerResizeHandle = useCallback(dragHandleId => {\n    return function resizeHandler(event) {\n      event.preventDefault();\n      const {\n        direction,\n        dragState,\n        id: groupId,\n        keyboardResizeByPercentage,\n        keyboardResizeByPixels,\n        onLayout\n      } = committedValuesRef.current;\n      const {\n        layout: prevLayout,\n        panelDataArray\n      } = eagerValuesRef.current;\n      const {\n        initialLayout\n      } = dragState !== null && dragState !== void 0 ? dragState : {};\n      const pivotIndices = determinePivotIndices(groupId, dragHandleId);\n      let delta = calculateDeltaPercentage(event, groupId, dragHandleId, direction, dragState, {\n        percentage: keyboardResizeByPercentage,\n        pixels: keyboardResizeByPixels\n      });\n      if (delta === 0) {\n        return;\n      }\n\n      // Support RTL layouts\n      const isHorizontal = direction === \"horizontal\";\n      if (document.dir === \"rtl\" && isHorizontal) {\n        delta = -delta;\n      }\n      const groupSizePixels = calculateAvailablePanelSizeInPixels(groupId);\n      const panelConstraints = panelDataArray.map(panelData => panelData.constraints);\n      const nextLayout = adjustLayoutByDelta({\n        delta,\n        groupSizePixels,\n        layout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,\n        panelConstraints,\n        pivotIndices,\n        trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\"\n      });\n      const layoutChanged = !compareLayouts(prevLayout, nextLayout);\n\n      // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n      // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n      if (isMouseEvent(event) || isTouchEvent(event)) {\n        // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n        // In this case, Panel sizes might not changeâ€“\n        // but updating cursor in this scenario would cause a flicker.\n        if (prevDeltaRef.current != delta) {\n          prevDeltaRef.current = delta;\n          if (!layoutChanged) {\n            // If the pointer has moved too far to resize the panel any further,\n            // update the cursor style for a visual clue.\n            // This mimics VS Code behavior.\n\n            if (isHorizontal) {\n              setGlobalCursorStyle(delta < 0 ? \"horizontal-min\" : \"horizontal-max\");\n            } else {\n              setGlobalCursorStyle(delta < 0 ? \"vertical-min\" : \"vertical-max\");\n            }\n          } else {\n            // Reset the cursor style to the the normal resize cursor.\n            setGlobalCursorStyle(isHorizontal ? \"horizontal\" : \"vertical\");\n          }\n        }\n      }\n      if (layoutChanged) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout.map(sizePercentage => ({\n            sizePercentage,\n            sizePixels: convertPercentageToPixels(sizePercentage, groupSizePixels)\n          })));\n        }\n        callPanelCallbacks(groupId, panelDataArray, nextLayout, panelIdToLastNotifiedMixedSizesMapRef.current);\n      }\n    };\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const resizePanel = useCallback((panelData, mixedSizes) => {\n    const {\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n    const {\n      groupSizePixels,\n      panelSizePercentage,\n      pivotIndices\n    } = panelDataHelper(groupId, panelDataArray, panelData, prevLayout);\n    const sizePercentage = getPercentageSizeFromMixedSizes(mixedSizes, groupSizePixels);\n    const isLastPanel = panelDataArray.indexOf(panelData) === panelDataArray.length - 1;\n    const delta = isLastPanel ? panelSizePercentage - sizePercentage : sizePercentage - panelSizePercentage;\n    const nextLayout = adjustLayoutByDelta({\n      delta,\n      groupSizePixels,\n      layout: prevLayout,\n      panelConstraints: panelConstraintsArray,\n      pivotIndices,\n      trigger: \"imperative-api\"\n    });\n    if (!compareLayouts(prevLayout, nextLayout)) {\n      setLayout(nextLayout);\n      eagerValuesRef.current.layout = nextLayout;\n      if (onLayout) {\n        onLayout(nextLayout.map(sizePercentage => ({\n          sizePercentage,\n          sizePixels: convertPercentageToPixels(sizePercentage, groupSizePixels)\n        })));\n      }\n      callPanelCallbacks(groupId, panelDataArray, nextLayout, panelIdToLastNotifiedMixedSizesMapRef.current);\n    }\n  }, [groupId]);\n  const startDragging = useCallback((dragHandleId, event) => {\n    const {\n      direction\n    } = committedValuesRef.current;\n    const {\n      layout\n    } = eagerValuesRef.current;\n    const handleElement = getResizeHandleElement(dragHandleId);\n    const initialCursorPosition = getResizeEventCursorPosition(direction, event);\n    setDragState({\n      dragHandleId,\n      dragHandleRect: handleElement.getBoundingClientRect(),\n      initialCursorPosition,\n      initialLayout: layout\n    });\n  }, []);\n  const stopDragging = useCallback(() => {\n    resetGlobalCursorStyle();\n    setDragState(null);\n  }, []);\n  const unregisterPanelRef = useRef({\n    pendingPanelIds: new Set(),\n    timeout: null\n  });\n  const unregisterPanel = useCallback(panelData => {\n    const {\n      id: groupId,\n      onLayout\n    } = committedValuesRef.current;\n    const {\n      layout: prevLayout,\n      panelDataArray\n    } = eagerValuesRef.current;\n    const index = panelDataArray.indexOf(panelData);\n    if (index >= 0) {\n      panelDataArray.splice(index, 1);\n      unregisterPanelRef.current.pendingPanelIds.add(panelData.id);\n    }\n    if (unregisterPanelRef.current.timeout != null) {\n      clearTimeout(unregisterPanelRef.current.timeout);\n    }\n\n    // Batch panel unmounts so that we only calculate layout once;\n    // This is more efficient and avoids misleading warnings in development mode.\n    // We can't check the DOM to detect this because Panel elements have not yet been removed.\n    unregisterPanelRef.current.timeout = setTimeout(() => {\n      const {\n        pendingPanelIds\n      } = unregisterPanelRef.current;\n      const map = panelIdToLastNotifiedMixedSizesMapRef.current;\n\n      // TRICKY\n      // Strict effects mode\n      let unmountDueToStrictMode = false;\n      pendingPanelIds.forEach(panelId => {\n        pendingPanelIds.delete(panelId);\n        if (panelDataArray.find(({\n          id\n        }) => id === panelId) == null) {\n          unmountDueToStrictMode = true;\n\n          // TRICKY\n          // When a panel is removed from the group, we should delete the most recent prev-size entry for it.\n          // If we don't do this, then a conditionally rendered panel might not call onResize when it's re-mounted.\n          // Strict effects mode makes this tricky though because all panels will be registered, unregistered, then re-registered on mount.\n          delete map[panelData.id];\n        }\n      });\n      if (!unmountDueToStrictMode) {\n        return;\n      }\n      if (panelDataArray.length === 0) {\n        // The group is unmounting; skip layout calculation.\n        return;\n      }\n      const groupSizePixels = calculateAvailablePanelSizeInPixels(groupId);\n      let unsafeLayout = calculateUnsafeDefaultLayout({\n        groupSizePixels,\n        panelDataArray\n      });\n\n      // Validate even saved layouts in case something has changed since last render\n      // e.g. for pixel groups, this could be the size of the window\n      const nextLayout = validatePanelGroupLayout({\n        groupSizePixels,\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\n      });\n      if (!areEqual(prevLayout, nextLayout)) {\n        setLayout(nextLayout);\n        eagerValuesRef.current.layout = nextLayout;\n        if (onLayout) {\n          onLayout(nextLayout.map(sizePercentage => ({\n            sizePercentage,\n            sizePixels: convertPercentageToPixels(sizePercentage, groupSizePixels)\n          })));\n        }\n        callPanelCallbacks(groupId, panelDataArray, nextLayout, panelIdToLastNotifiedMixedSizesMapRef.current);\n      }\n    }, 0);\n  }, []);\n  const context = useMemo(() => ({\n    collapsePanel,\n    direction,\n    dragState,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    isPanelExpanded,\n    registerPanel,\n    registerResizeHandle,\n    resizePanel,\n    startDragging,\n    stopDragging,\n    unregisterPanel\n  }), [collapsePanel, dragState, direction, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, isPanelExpanded, registerPanel, registerResizeHandle, resizePanel, startDragging, stopDragging, unregisterPanel]);\n  const style = {\n    display: \"flex\",\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    width: \"100%\"\n  };\n  return createElement(PanelGroupContext.Provider, {\n    value: context\n  }, createElement(Type, {\n    children,\n    className: classNameFromProps,\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    ...dataAttributes,\n    // CSS selectors\n    \"data-panel-group\": \"\",\n    \"data-panel-group-direction\": direction,\n    \"data-panel-group-id\": groupId\n  }));\n}\nconst PanelGroup = forwardRef((props, ref) => createElement(PanelGroupWithForwardedRef, {\n  ...props,\n  forwardedRef: ref\n}));\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\nfunction panelDataHelper(groupId, panelDataArray, panelData, layout) {\n  const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\n  const panelIndex = panelDataArray.indexOf(panelData);\n  const panelConstraints = panelConstraintsArray[panelIndex];\n  const groupSizePixels = calculateAvailablePanelSizeInPixels(groupId);\n  const percentagePanelConstraints = computePercentagePanelConstraints(panelConstraintsArray, panelIndex, groupSizePixels);\n  const isLastPanel = panelIndex === panelDataArray.length - 1;\n  const pivotIndices = isLastPanel ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1];\n  const panelSizePercentage = layout[panelIndex];\n  const panelSizePixels = convertPercentageToPixels(panelSizePercentage, groupSizePixels);\n  return {\n    ...percentagePanelConstraints,\n    collapsible: panelConstraints.collapsible,\n    panelSizePercentage,\n    panelSizePixels,\n    groupSizePixels,\n    pivotIndices\n  };\n}\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nfunction useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler\n}) {\n  useEffect(() => {\n    if (disabled || resizeHandler == null) {\n      return;\n    }\n    const handleElement = getResizeHandleElement(handleId);\n    if (handleElement == null) {\n      return;\n    }\n    const onKeyDown = event => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\":\n          {\n            event.preventDefault();\n            resizeHandler(event);\n            break;\n          }\n        case \"F6\":\n          {\n            event.preventDefault();\n            const groupId = handleElement.getAttribute(\"data-panel-group-id\");\n            const handles = getResizeHandleElementsForGroup(groupId);\n            const index = getResizeHandleElementIndex(groupId, handleId);\n            assert(index !== null);\n            const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\n            const nextHandle = handles[nextIndex];\n            nextHandle.focus();\n            break;\n          }\n      }\n    };\n    handleElement.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [disabled, handleId, resizeHandler]);\n}\n\nfunction PanelResizeHandle({\n  children = null,\n  className: classNameFromProps = \"\",\n  dataAttributes,\n  disabled = false,\n  id: idFromProps = null,\n  onDragging,\n  style: styleFromProps = {},\n  tagName: Type = \"div\"\n}) {\n  const divElementRef = useRef(null);\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef({\n    onDragging\n  });\n  useEffect(() => {\n    callbacksRef.current.onDragging = onDragging;\n  });\n  const panelGroupContext = useContext(PanelGroupContext);\n  if (panelGroupContext === null) {\n    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\n  }\n  const {\n    direction,\n    dragState,\n    groupId,\n    registerResizeHandle,\n    startDragging,\n    stopDragging\n  } = panelGroupContext;\n  const resizeHandleId = useUniqueId(idFromProps);\n  const isDragging = (dragState === null || dragState === void 0 ? void 0 : dragState.dragHandleId) === resizeHandleId;\n  const [isFocused, setIsFocused] = useState(false);\n  const [resizeHandler, setResizeHandler] = useState(null);\n  const stopDraggingAndBlur = useCallback(() => {\n    // Clicking on the drag handle shouldn't leave it focused;\n    // That would cause the PanelGroup to think it was still active.\n    const div = divElementRef.current;\n    div.blur();\n    stopDragging();\n    const {\n      onDragging\n    } = callbacksRef.current;\n    if (onDragging) {\n      onDragging(false);\n    }\n  }, [stopDragging]);\n  useEffect(() => {\n    if (disabled) {\n      setResizeHandler(null);\n    } else {\n      const resizeHandler = registerResizeHandle(resizeHandleId);\n      setResizeHandler(() => resizeHandler);\n    }\n  }, [disabled, resizeHandleId, registerResizeHandle]);\n  useEffect(() => {\n    if (disabled || resizeHandler == null || !isDragging) {\n      return;\n    }\n    const onMove = event => {\n      resizeHandler(event);\n    };\n    const onMouseLeave = event => {\n      resizeHandler(event);\n    };\n    const divElement = divElementRef.current;\n    const targetDocument = divElement.ownerDocument;\n    targetDocument.body.addEventListener(\"contextmenu\", stopDraggingAndBlur);\n    targetDocument.body.addEventListener(\"mousemove\", onMove);\n    targetDocument.body.addEventListener(\"touchmove\", onMove);\n    targetDocument.body.addEventListener(\"mouseleave\", onMouseLeave);\n    window.addEventListener(\"mouseup\", stopDraggingAndBlur);\n    window.addEventListener(\"touchend\", stopDraggingAndBlur);\n    return () => {\n      targetDocument.body.removeEventListener(\"contextmenu\", stopDraggingAndBlur);\n      targetDocument.body.removeEventListener(\"mousemove\", onMove);\n      targetDocument.body.removeEventListener(\"touchmove\", onMove);\n      targetDocument.body.removeEventListener(\"mouseleave\", onMouseLeave);\n      window.removeEventListener(\"mouseup\", stopDraggingAndBlur);\n      window.removeEventListener(\"touchend\", stopDraggingAndBlur);\n    };\n  }, [direction, disabled, isDragging, resizeHandler, stopDraggingAndBlur]);\n  useWindowSplitterResizeHandlerBehavior({\n    disabled,\n    handleId: resizeHandleId,\n    resizeHandler\n  });\n  const style = {\n    cursor: getCursorStyle(direction),\n    touchAction: \"none\",\n    userSelect: \"none\"\n  };\n  return createElement(Type, {\n    children,\n    className: classNameFromProps,\n    onBlur: () => setIsFocused(false),\n    onFocus: () => setIsFocused(true),\n    onMouseDown: event => {\n      startDragging(resizeHandleId, event.nativeEvent);\n      const {\n        onDragging\n      } = callbacksRef.current;\n      if (onDragging) {\n        onDragging(true);\n      }\n    },\n    onMouseUp: stopDraggingAndBlur,\n    onTouchCancel: stopDraggingAndBlur,\n    onTouchEnd: stopDraggingAndBlur,\n    onTouchStart: event => {\n      startDragging(resizeHandleId, event.nativeEvent);\n      const {\n        onDragging\n      } = callbacksRef.current;\n      if (onDragging) {\n        onDragging(true);\n      }\n    },\n    ref: divElementRef,\n    role: \"separator\",\n    style: {\n      ...style,\n      ...styleFromProps\n    },\n    tabIndex: 0,\n    ...dataAttributes,\n    // CSS selectors\n    \"data-panel-group-direction\": direction,\n    \"data-panel-group-id\": groupId,\n    \"data-resize-handle\": \"\",\n    \"data-resize-handle-active\": isDragging ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\n    \"data-panel-resize-handle-enabled\": !disabled,\n    \"data-panel-resize-handle-id\": resizeHandleId\n  });\n}\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\n\nexport { Panel, PanelGroup, PanelResizeHandle };\n","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { Panel as ReactPanel } from 'react-resizable-panels';\r\n\r\nconst Panel = (props) => {\r\n    const { children, setProps, ...other } = props;\r\n\r\n    return (\r\n        <ReactPanel {...other}>\r\n            {children}\r\n        </ReactPanel>\r\n    );\r\n}\r\n\r\nPanel.defaultProps = {};\r\n\r\nPanel.propTypes = {\r\n    /**\r\n     * The ID used to identify this component in Dash callbacks.\r\n     */\r\n    id: PropTypes.string,\r\n\r\n    /**\r\n     * The children of this component.\r\n     */\r\n    children: PropTypes.node,\r\n\r\n    /**\r\n     * Updates the component's props.\r\n     */\r\n    setProps: PropTypes.func,\r\n\r\n    /**\r\n     * class name for the panel group\r\n    */\r\n    className: PropTypes.string,\r\n\r\n    /**\r\n     * Panel should collapse to this size\r\n    */\r\n    collapsedSize: PropTypes.number,\r\n\r\n    /**\r\n     * Panel should collapse when resized beyond its minSize\r\n    */\r\n    collapsible: PropTypes.bool,\r\n\r\n    /**\r\n     * Initial size of panel (numeric value between 1-100)\r\n    */\r\n    defaultSize: PropTypes.number,\r\n\r\n    /**\r\n     * Minimum size of panel (numeric value between 1-100)\r\n    */\r\n    minSize: PropTypes.number,\r\n\r\n    /**\r\n     * Maximum size of panel (numeric value between 1-100)\r\n    */\r\n    maxSize: PropTypes.number,\r\n\r\n    /**\r\n     * Order of panel within group; required for groups with conditionally rendered panels\r\n    */\r\n    order: PropTypes.number,\r\n\r\n    /**\r\n     * style for the panel group\r\n    */\r\n    style: PropTypes.object,\r\n};\r\n\r\nexport default Panel;","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { PanelGroup as ReactPanelGroup } from 'react-resizable-panels';\r\n\r\nconst PanelGroup = (props) => {\r\n    const { children, setProps, ...other } = props;\r\n\r\n    return (\r\n        <ReactPanelGroup {...other}>\r\n            {children}\r\n        </ReactPanelGroup>\r\n    );\r\n}\r\n\r\nPanelGroup.defaultProps = {};\r\n\r\nPanelGroup.propTypes = {\r\n    /**\r\n     * The ID used to identify this component in Dash callbacks.\r\n     */\r\n    id: PropTypes.string,\r\n\r\n    /**\r\n     * The children of this component.\r\n     */\r\n    children: PropTypes.node,\r\n\r\n    /**\r\n     * Updates the component's props.\r\n     */\r\n    setProps: PropTypes.func,\r\n\r\n    /**\r\n     * Unique id used to aut-save group arragement via local storage.\r\n    */\r\n    autoSaveId: PropTypes.string,\r\n\r\n    /**\r\n     * class name for the panel group\r\n    */\r\n    className: PropTypes.string,\r\n\r\n    /**\r\n     * Direction of the panel group\r\n    */\r\n    direction: PropTypes.string,\r\n\r\n    /**\r\n     * style for the panel group\r\n    */\r\n    style: PropTypes.object,\r\n};\r\n\r\nexport default PanelGroup;","import React from 'react';\r\nimport PropTypes from 'prop-types';\r\nimport { PanelResizeHandle as ReactPanelResizeHandle } from 'react-resizable-panels';\r\n\r\nconst PanelResizeHandle = (props) => {\r\n    const { children, setProps, ...other } = props;\r\n\r\n    return (\r\n        <ReactPanelResizeHandle {...other}>\r\n            {children}\r\n        </ReactPanelResizeHandle>\r\n    );\r\n}\r\n\r\nPanelResizeHandle.defaultProps = {};\r\n\r\nPanelResizeHandle.propTypes = {\r\n    /**\r\n     * The ID used to identify this component in Dash callbacks.\r\n     */\r\n    id: PropTypes.string,\r\n\r\n    /**\r\n     * The children of this component.\r\n     */\r\n    children: PropTypes.node,\r\n\r\n    /**\r\n     * Updates the component's props.\r\n     */\r\n    setProps: PropTypes.func,\r\n\r\n    /**\r\n     * class name for the panel group\r\n    */\r\n    className: PropTypes.string,\r\n\r\n    /**\r\n     * Disable drag handle\r\n    */\r\n    disable: PropTypes.bool,\r\n\r\n    /**\r\n     * style for the panel group\r\n    */\r\n    style: PropTypes.object,\r\n};\r\n\r\nexport default PanelResizeHandle;"],"names":["url","__webpack_require__","module","getter","__esModule","d","a","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","getCurrentScript","script","document","currentScript","doc_scripts","getElementsByTagName","scripts","i","length","push","filter","s","async","text","textContent","slice","src","split","join","jsonpScriptSrc","__jsonpScriptSrc__","chunkId","isLocal","test","srcFragments","fileFragments","splice","window","createElement","createContext","createRef","forwardRef","useCallback","useContext","useEffect","useImperativeHandle","useLayoutEffect","useMemo","useRef","useState","useId","toString","PanelGroupContext","displayName","useIsomorphicLayoutEffect","wrappedUseId","counter","useUniqueId","idFromParams","idFromUseId","idRef","current","PanelWithForwardedRef","children","className","classNameFromProps","collapsedSizePercentage","collapsedSizePixels","collapsible","dataAttributes","defaultSizePercentage","defaultSizePixels","forwardedRef","id","idFromProps","maxSizePercentage","maxSizePixels","minSizePercentage","minSizePixels","onCollapse","onExpand","onResize","order","style","styleFromProps","tagName","Type","context","Error","collapsePanel","expandPanel","getPanelSize","getPanelStyle","groupId","isPanelCollapsed","registerPanel","resizePanel","unregisterPanel","panelId","panelDataRef","callbacks","constraints","idIsFromProps","undefined","didLogMissingDefaultSizeWarning","panelData","collapse","expand","getId","getSize","isCollapsed","isExpanded","resize","mixedSizes","props","ref","convertPixelsToPercentage","pixels","groupSizePixels","convertPixelConstraintsToPercentages","panelConstraints","console","warn","computePercentagePanelConstraints","panelConstraintsArray","panelIndex","totalMinConstraints","totalMaxConstraints","index","Math","min","max","PRECISION","fuzzyCompareNumbers","actual","expected","fractionDigits","delta","parseFloat","toFixed","fuzzyNumbersEqual","size","some","adjustLayoutByDelta","layout","prevLayout","pivotIndices","trigger","nextLayout","deltaApplied","prevSize","localDelta","abs","increment","maxAvailableDelta","minAbsDelta","deltaRemaining","safeSize","toPrecision","localeCompare","numeric","pivotIndex","unsafeSize","totalSize","reduce","total","assert","expectedCondition","message","error","getPercentageSizeFromMixedSizes","sizePercentage","sizePixels","calculateAriaValues","panelsArray","currentMinSize","currentMaxSize","totalMinSize","totalMaxSize","forEach","_getPercentageSizeFro","_getPercentageSizeFro2","minSize","maxSize","valueMax","valueMin","valueNow","getResizeHandleElementsForGroup","Array","from","querySelectorAll","getResizeHandleElementIndex","findIndex","handle","getAttribute","determinePivotIndices","dragHandleId","getPanelGroupElement","querySelector","calculateAvailablePanelSizeInPixels","panelGroupElement","NaN","direction","resizeHandles","offsetWidth","accumulated","offsetHeight","getResizeHandleElement","areEqual","arrayA","arrayB","isKeyDown","event","type","isMouseEvent","startsWith","isTouchEvent","getResizeEventCursorPosition","isHorizontal","clientX","clientY","firstTouch","touches","screenX","screenY","calculateUnsafeDefaultLayout","panelDataArray","panelDataConstraints","map","numPanelsWithSizes","remainingSize","convertPercentageToPixels","percentage","callPanelCallbacks","panelIdToLastNotifiedMixedSizesMap","lastNotifiedMixedSizes","collapsedSize","compareLayouts","b","currentState","getCursorStyle","state","initializeDefaultStorage","storageObject","localStorage","getItem","name","setItem","getSerializationKey","panels","panel","JSON","stringify","sort","loadSerializedPanelGroupState","autoSaveId","storage","serialized","parsed","parse","savePanelGroupLayout","sizes","shouldMonitorPixelBasedConstraints","validatePanelGroupLayout","defaultStorage","debounceMap","PanelGroupWithForwardedRef","onLayout","keyboardResizeByPercentage","keyboardResizeByPixels","dragState","setDragState","setLayout","panelIdToLastNotifiedMixedSizesMapRef","panelSizeBeforeCollapseRef","Map","prevDeltaRef","committedValuesRef","eagerValuesRef","didLogIdAndOrderWarning","didLogPanelConstraintsWarning","prevPanelIds","getLayout","unsafeLayout","mixedSize","safeLayout","didWarnAboutMissingResizeHandle","resizeHandleElements","resizeHandleElement","setAttribute","round","removeAttribute","cleanupFunctions","handleId","idBefore","idAfter","_panelsArray$index$id","_panelsArray$index","_panelsArray$id","_panelsArray","handles","indexOf","getResizeHandlePanelIds","onKeyDown","defaultPrevented","preventDefault","getAvailableGroupSizePixels","addEventListener","removeEventListener","cleanupFunction","useWindowSplitterPanelGroupBehavior","callback","durationMs","timeoutId","args","clearTimeout","setTimeout","debounce","ResizeObserver","resizeObserver","observe","disconnect","panelSizePercentage","panelDataHelper","set","prevPanelSizePercentage","baseSizePercentage","panelSizePixels","precision","flexGrow","flexBasis","flexShrink","overflow","pointerEvents","computePanelFlexBoxStyle","isPanelExpanded","panelA","panelB","orderA","orderB","panelElements","getPanelElementsForGroup","_state$key","loadPanelLayout","registerResizeHandle","initialLayout","initialDragState","keyboardResizeByOptions","rect","getBoundingClientRect","groupSizeInPixels","width","height","shiftKey","movement","initialCursorPosition","cursorPosition","groupRect","calculateDragOffsetPercentage","calculateDeltaPercentage","dir","layoutChanged","head","appendChild","innerHTML","setGlobalCursorStyle","startDragging","handleElement","dragHandleRect","stopDragging","removeChild","unregisterPanelRef","pendingPanelIds","Set","timeout","add","unmountDueToStrictMode","delete","find","display","flexDirection","Provider","percentagePanelConstraints","disabled","onDragging","divElementRef","callbacksRef","panelGroupContext","resizeHandleId","isDragging","isFocused","setIsFocused","resizeHandler","setResizeHandler","stopDraggingAndBlur","blur","onMove","onMouseLeave","targetDocument","ownerDocument","body","focus","useWindowSplitterResizeHandlerBehavior","cursor","touchAction","userSelect","onBlur","onFocus","onMouseDown","nativeEvent","onMouseUp","onTouchCancel","onTouchEnd","onTouchStart","role","tabIndex","Panel","other","setProps","_objectWithoutProperties","_excluded","React","ReactPanel","defaultProps","propTypes","PropTypes","defaultSize","PanelGroup","ReactPanelGroup","PanelResizeHandle","ReactPanelResizeHandle","disable"],"sourceRoot":""}